[
  {
    "objectID": "ginzburg.html",
    "href": "ginzburg.html",
    "title": "Quarto demo",
    "section": "",
    "text": "Test of Potts model\n\nusing WGLMakie\nusing LinearAlgebra\nusing CircularArrays\nusing StatsBase: Weights, sample\nusing Random: MersenneTwister\nusing Distributions\nusing MakiePublication\nusing QuartoTools\n\n\nham(J, q::Int, n1::Int, n2::Int) = J*cos(2pi / q * (n1 - n2))\n\nham (generic function with 1 method)\n\n\n\nfunction choose_weights(_s, _q)\n  # choses weights for spin flip\n  weights = Weights(ones(_q)/(_q-1))\n  weights[_s+1] = 0.0 # set probability to choose spin-i again to be zero\n  return weights\nend\n\nfunction spin_flip(_si, _q)\n  # randomly chooses ANOTHER spin\n  # spin = round(Int,_si / 2pi * _q) # convert to integer selection\n\n  w = choose_weights(_si, _q)\n  return sample(0:q-1, w)\nend\n\nspin_flip (generic function with 1 method)\n\n\n\nq = 4  # theta discreteness\nN = 64\n\nn_dims = (N, N)\nkB = 5.0\nJ = -1.0\nspins = CircularArray(sample(0:q-1, Weights(ones(q)/q), n_dims)) \n\n\n# neighbors\nlocs      = eachindex(spins)\nbasis_vec = eachcol(diagm(ones(Int8,length(n_dims)))) # general dimensions\nneighbors = map(_n-&gt;CartesianIndex(_n...), [basis_vec; -basis_vec])\n\nMAXITER  = 100_000\nSTEP     = MAXITER ÷ 1000\ntime     = LinRange(0, 1, MAXITER)\nβmax     = 50.0\nβ        = @. βmax * ((1 + exp(-2*(time-1/2)*10))^-1 - 1/2)  #@. βmin  - 2βmin*time\ntemp     = @. 1.0 / β\n\nspin_vec = zeros(size(spins)..., MAXITER)\n\nfor k in 1:MAXITER\n\n  spin_vec[:,:,k] = spins.data # save state\n\n\n  i = rand(locs) # choose random spin location\n  si = spins[i]\n\n  nearest = i .+ neighbors\n  \n  energy = mapreduce(sj -&gt; ham(J, q, si, sj), +, spins[nearest]) # sum \n\n  si_new = spin_flip(si, q)\n\n  energy_new = mapreduce(sj -&gt; ham(J, q, si_new, sj), +, spins[nearest]) # sum \n  dE = energy_new - energy\n\n  if dE &lt; 0.0\n    spins[i] = si_new\n  elseif rand() &lt; exp(-dE * β[k])\n    spins[i] = si_new\n  end\nend"
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "Gallery",
    "section": "",
    "text": "Pre-graduation in Monterrey\n\n\n\n\n\nReflections in Memorial park\n\n\n\n\n\nJames Turrel’s “Twilight Epiphany”\n\n\n\n\n\nMonterrey as seen from El Cerro de la Silla",
    "crumbs": [
      "Gallery"
    ]
  },
  {
    "objectID": "posts/ginzburg.html",
    "href": "posts/ginzburg.html",
    "title": "Landau-Ginzburg",
    "section": "",
    "text": "Essentiaylly, one expands the free energy functional \\(F[m]\\) in \\(m\\) and its gradients while satisfying the proposed symmetries. The coarse-grained extension to the Ising Hamiltonian is given by a Landau-Ginzburg Hamiltonian\n\\[\\begin{equation}\n  H[m] = \\int d\\vec{r}\\left[ \\frac{a}{2}m^2 + bm^4 + \\frac{K}{2} (\\nabla m)^2 +\\dots\\right]\n\\end{equation}\\]\nThis has profound consequences in the statistical theory of fields (using saddle-point approximations to recover Landau’s theory), but I won’t discuss this here (see Kardar’s book). Here, \\(m(\\vec{x})\\) can be interpreted to be order-parameters, but in essence are random fields, i.e. a field with a Boltzmann weight.\nThe above expression is not a kinetic expression. If we want to analyze the relaxation of a system to the equilibrium configuration, we should introduce dynamics of the field \\(m(\\vec{x})\\), which are given by a Langevin equation\n\\[\\begin{equation}\n  \\dot{\\vec{x}}=\\vec{v}(\\vec{x})+\\vec{\\eta}(t),\n\\end{equation}\\]\nwhere the second term, the stochastic velocity, has zero mean. It is direct to see that for our Landau-Ginzburg Hamiltonian we have\n\\[\\begin{align}\n\\partial_t m_i(\\vec{x},t) &=\\mu F_i(\\vec{x})+\\eta_i(\\vec{x},t)\\\\\\\\\n                              &=-\\mu\\frac{\\delta F_i}{\\delta m_i(\\vec{x})}+\\eta_i(\\vec{x},t)\\\\\\\\\n                              &=-\\mu(am_i+4b m_i|\\vec{m}|^2-K\\nabla^2m_i)+\\eta_i(\\vec{x},t)\\\\\\\\\n  \\partial_t \\vec{m}(\\vec{x},t)&=-\\mu(a\\vec{m}+4b \\vec{m}|\\vec{m}|^2-K\\nabla^2\\vec{m})+\\eta_i(\\vec{x},t)\n\\end{align}\\]\nThis last equation is the time-dependent Landau-Ginzburg Hamiltonian. Since this is a nonlinear equation, we resort to numerical methods to solve for the dynamics.\n\n\nThe order parameter or field has no restrictions on its dimensions. Simulating a bidimensional magnetization can be achieved by using complex numbers (say real for (m_x) and imaginary for (m_y)). Lets focus on a scalar field first and see how it evolves in time, first in 2D and then in 3D.\n\n\n\nConsider a complex field (). We set the parameter (a) to be negative for us to have Goldstone modes. We further set (b=1.0 + 1.5i) after some examples I saw after lurking online for the time-dependent LG equation.\nTo simulate the 2D case, we can use Julia’s DifferentialEquations.jl package to solve for a complex field (). The spatial gradients were implemented as convolution operators using custom finite difference kernels, which were generated by the finite_diff_coefficient and get_laplace_kernel functions.\nfunction finite_diff_coefficient(_ord::Int64)\n  if _ord == 2\n    return [1,-2,1]\n  elseif _ord == 4\n    return [-1/12, 4/3, -5/2, 4/3, -1/12]\n  elseif _ord == 6\n    return [1/90, -3/20, 3/2, -49/18,3/2,-3/20,1/90]\n  elseif _ord == 8\n    return [-1/560,8/315,-1/5,8/5,-205/72,8/5,-1/5,8/315,-1/560]\n  end\nend\nThe idea for this is to be able to implement the kernel in any number of dimensions, therefore these functions work for both 2D and 3D (and even 1D if you want to try it out).\nfunction get_laplace_kernel(_dim::Int64,_ord::Int64)\n  base_ker = finite_diff_coefficient(_ord)\n  kernel = zeros(fill(length(base_ker),_dim)...)\n  mid_index = _ord÷2+1\n  kernel[fill(mid_index,ndims(kernel)-1)...,:] .= base_ker # middle of middles\n  \n  perm_ind = collect(permutations(1:_dim))#[1:_dim-1:end]\n  if _dim == 3\n  filter!(_i -&gt; levicivita(_i) &lt; 0, perm_ind)\n  end\n  kernel = mapreduce(_i -&gt; permutedims(kernel,_i),+,perm_ind)\n  \n\n  #two_dim_ker += permutedims(two_dim_ker)\n  return centered(kernel) # return centered version of kernel (0 = middle)\nend\nFinally, the dynamics were defined in the diff_eq function, which computes the time derivative of the field (u) based on the parameters (), (a), (b), (K), and the Laplacian kernel. The periodic boundary conditions were handled using circular convolution from the ImageFiltering package in Julia (thankful I did not have to program the convolutions myself!). This approach may be most efficient for 2D arrays, and makes it simpler to implement and worry about the physics rather than the programming details (like the periodic boundary conditions).\nfunction diff_eq(u , p, t)\n  # dp/dt = mu*F+eta\n  μ,a,b,K,del_sq,dx = p\n  return -μ*(a * u + 4*b*abs2.(u) .* u - K * imfilter(u, del_sq, \"circular\") / dx^2) # periodic boudnary conditions\nend\nThe following heatmap shows the results of an initial random spin configuration (like with the ising model). I believe the sustained oscillations are due to the system exploring the possible configurations. For example, in a 1D Heisenberg model (XY model), one can think of the order parameter () to be degenerate since (for the certain parameters) rotations around the () axis will not affect the free energy. Such states are called low-energy excitations of the system.\n\nOne can check that this absence of low-energy excitations can also happen for a complex-valued field ((b)), as long as (a&gt;0). As seen above, the order parameter is “free” to explore all the configurations around the black line. However, when we initialize the system in a purely real field (or with $a&gt;0$), there are no low-energy excitations present, and instead the system relaxes towards a single minima.\n\n\n\n    \n    \n    \n    \n    \n\n\n\n\n\n\nI have already explained that the above functions work for ay dimension. However, the only change is that in 3D, multiplication becomes a bit more expensive, and we’re dealing with even more data-points. It is convenient to use a simple workhorse for solving the dynamics, the Euler method with small time step. We also include a random (Gaussian) velocity in each time-step as to account for random fluctuations.\nHere, rather than starting with a random distribution, we start with a Gaussian field at the origin. As expected, low-energy excitations emerge.\n\n\n\nA friend interested in phase separation (and more experience in physics than I) suggested I read about the Cahn-Hilliard model after showing him the simluations above. Modifying the above code is trivial (just includes another convolution); below is a simulation of such separation using a balanced mixture (following the Cahn-Hilliard model), when constrained to a box (i.e. no periodic boundary conditions).\n\nThere is a great discussion on so called dissipative stochastic models (i.e. kinetic Ising models) in the wonderful book by Chaikin and Lubensky. It should be fun to implement the remaining models in the A-J list shown in page 467.",
    "crumbs": [
      "Posts",
      "Landau-Ginzburg"
    ]
  },
  {
    "objectID": "posts/ginzburg.html#solving-the-time-dependent-landau-ginzburg-equation",
    "href": "posts/ginzburg.html#solving-the-time-dependent-landau-ginzburg-equation",
    "title": "Landau-Ginzburg",
    "section": "",
    "text": "The order parameter or field has no restrictions on its dimensions. Simulating a bidimensional magnetization can be achieved by using complex numbers (say real for (m_x) and imaginary for (m_y)). Lets focus on a scalar field first and see how it evolves in time, first in 2D and then in 3D.",
    "crumbs": [
      "Posts",
      "Landau-Ginzburg"
    ]
  },
  {
    "objectID": "posts/ginzburg.html#d-treatment",
    "href": "posts/ginzburg.html#d-treatment",
    "title": "Landau-Ginzburg",
    "section": "",
    "text": "Consider a complex field (). We set the parameter (a) to be negative for us to have Goldstone modes. We further set (b=1.0 + 1.5i) after some examples I saw after lurking online for the time-dependent LG equation.\nTo simulate the 2D case, we can use Julia’s DifferentialEquations.jl package to solve for a complex field (). The spatial gradients were implemented as convolution operators using custom finite difference kernels, which were generated by the finite_diff_coefficient and get_laplace_kernel functions.\nfunction finite_diff_coefficient(_ord::Int64)\n  if _ord == 2\n    return [1,-2,1]\n  elseif _ord == 4\n    return [-1/12, 4/3, -5/2, 4/3, -1/12]\n  elseif _ord == 6\n    return [1/90, -3/20, 3/2, -49/18,3/2,-3/20,1/90]\n  elseif _ord == 8\n    return [-1/560,8/315,-1/5,8/5,-205/72,8/5,-1/5,8/315,-1/560]\n  end\nend\nThe idea for this is to be able to implement the kernel in any number of dimensions, therefore these functions work for both 2D and 3D (and even 1D if you want to try it out).\nfunction get_laplace_kernel(_dim::Int64,_ord::Int64)\n  base_ker = finite_diff_coefficient(_ord)\n  kernel = zeros(fill(length(base_ker),_dim)...)\n  mid_index = _ord÷2+1\n  kernel[fill(mid_index,ndims(kernel)-1)...,:] .= base_ker # middle of middles\n  \n  perm_ind = collect(permutations(1:_dim))#[1:_dim-1:end]\n  if _dim == 3\n  filter!(_i -&gt; levicivita(_i) &lt; 0, perm_ind)\n  end\n  kernel = mapreduce(_i -&gt; permutedims(kernel,_i),+,perm_ind)\n  \n\n  #two_dim_ker += permutedims(two_dim_ker)\n  return centered(kernel) # return centered version of kernel (0 = middle)\nend\nFinally, the dynamics were defined in the diff_eq function, which computes the time derivative of the field (u) based on the parameters (), (a), (b), (K), and the Laplacian kernel. The periodic boundary conditions were handled using circular convolution from the ImageFiltering package in Julia (thankful I did not have to program the convolutions myself!). This approach may be most efficient for 2D arrays, and makes it simpler to implement and worry about the physics rather than the programming details (like the periodic boundary conditions).\nfunction diff_eq(u , p, t)\n  # dp/dt = mu*F+eta\n  μ,a,b,K,del_sq,dx = p\n  return -μ*(a * u + 4*b*abs2.(u) .* u - K * imfilter(u, del_sq, \"circular\") / dx^2) # periodic boudnary conditions\nend\nThe following heatmap shows the results of an initial random spin configuration (like with the ising model). I believe the sustained oscillations are due to the system exploring the possible configurations. For example, in a 1D Heisenberg model (XY model), one can think of the order parameter () to be degenerate since (for the certain parameters) rotations around the () axis will not affect the free energy. Such states are called low-energy excitations of the system.\n\nOne can check that this absence of low-energy excitations can also happen for a complex-valued field ((b)), as long as (a&gt;0). As seen above, the order parameter is “free” to explore all the configurations around the black line. However, when we initialize the system in a purely real field (or with $a&gt;0$), there are no low-energy excitations present, and instead the system relaxes towards a single minima.",
    "crumbs": [
      "Posts",
      "Landau-Ginzburg"
    ]
  },
  {
    "objectID": "posts/ginzburg.html#d-treatment-1",
    "href": "posts/ginzburg.html#d-treatment-1",
    "title": "Landau-Ginzburg",
    "section": "",
    "text": "I have already explained that the above functions work for ay dimension. However, the only change is that in 3D, multiplication becomes a bit more expensive, and we’re dealing with even more data-points. It is convenient to use a simple workhorse for solving the dynamics, the Euler method with small time step. We also include a random (Gaussian) velocity in each time-step as to account for random fluctuations.\nHere, rather than starting with a random distribution, we start with a Gaussian field at the origin. As expected, low-energy excitations emerge.\n\n\n\nA friend interested in phase separation (and more experience in physics than I) suggested I read about the Cahn-Hilliard model after showing him the simluations above. Modifying the above code is trivial (just includes another convolution); below is a simulation of such separation using a balanced mixture (following the Cahn-Hilliard model), when constrained to a box (i.e. no periodic boundary conditions).\n\nThere is a great discussion on so called dissipative stochastic models (i.e. kinetic Ising models) in the wonderful book by Chaikin and Lubensky. It should be fun to implement the remaining models in the A-J list shown in page 467.",
    "crumbs": [
      "Posts",
      "Landau-Ginzburg"
    ]
  },
  {
    "objectID": "posts/ginzburg.html#simulating-the-classical-potts-model",
    "href": "posts/ginzburg.html#simulating-the-classical-potts-model",
    "title": "Landau-Ginzburg",
    "section": "Simulating the classical Potts model",
    "text": "Simulating the classical Potts model\n\nFor larger and larger \\(q\\), we see that it starts to resemble what we had before with the LG model. Because this is a classical model, fluctuations are due to temperature only.",
    "crumbs": [
      "Posts",
      "Landau-Ginzburg"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/tutorials/mirror.html",
    "href": "posts/boundary-wall/docs/tutorials/mirror.html",
    "title": "Beam Splitter",
    "section": "",
    "text": "Beam Splitter\n\n\n\nalt text\n\n\n\n\nBragg Mirror\n\n\n\nalt text",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Tutorials",
      "Beam Splitter"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/introduction.html",
    "href": "posts/boundary-wall/docs/introduction.html",
    "title": "Application to optical problems",
    "section": "",
    "text": "Essentially, a Boundary Integral Method (BIM) reduces the degrees of freedom of a problem to those of the boundary. It also means that the problem becomes meshless, which means that there is no need for simple domains.\nHowever, the method relies on a more abstract notion of integral operators (rather than differential equations). Furthermore, most of the matrices are dense, which While numerical integration can be more stable than numerical differentiation, one may need to project the continuous integral onto a finite-dimensional space of functions, which can be tricky to account for corners (infinite information in Fourier spectrum).\nIn the method implemented below, a matrix is associated to the required kernel for the integral operator. The chosen kernel will dictate how well-behaved (or well-conditioned) the matrix will be, and thus which algorithms can be used to solve a system (A=).\nThis raises an important detail about possible applications. This is a Boundary Integral Method, which limits the applicable domains to 2D curves consisting of: simply connected curves, open curves, or a collection of the previous two. Boundaries with intersections and inner loops will generally not work. While the method does not require a parametrization of the boundary, it does require certain homogeneity in arc length. For more details about the implementation and theoretical foundations, see the Geometry section.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Application to optical problems"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/introduction.html#beam-shaping",
    "href": "posts/boundary-wall/docs/introduction.html#beam-shaping",
    "title": "Application to optical problems",
    "section": "Beam shaping",
    "text": "Beam shaping\nContinuous (real-angle) beam shaping seems less difficult once one realizes that, as long as the incident wave () is a solution of the Helmholtz equation, then any linear combination is admissible for the algorithm. For example, an integral of the form\n[_z()= ; A(),(,)]\neffectively molds plane waves into another beam, determined by its spectrum (A()). A simple beam to test is a Gaussian beam, since its spectrum is also a Gaussian.\n\nOne can also simulate photonic crystals composed of individual rods. For example, by creating a lattice with ellipse-like boundaries, it can imitate a meta-optical surface, where by adjusting angles and certain parameters, one can have a non-linear response for different frequencies (i.e. multiplexing).",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Application to optical problems"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/introduction.html#banded-matrices",
    "href": "posts/boundary-wall/docs/introduction.html#banded-matrices",
    "title": "Application to optical problems",
    "section": "Banded matrices",
    "text": "Banded matrices\nBriefly, one performs a quadrature for curve elements within the range (|i-j|&lt;&lt; N). Setting (|i-j|=N-1) yields a fully integrated method, while using (|i-j|=0) results in a fully discretized version. We have found that, for TM polarization, even setting as low as (|i-j|=1) takes similar time and allocations as with (|i-j|=0), but with increased acccuracy.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Application to optical problems"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/introduction.html#electromagnetic-problem",
    "href": "posts/boundary-wall/docs/introduction.html#electromagnetic-problem",
    "title": "Application to optical problems",
    "section": "Electromagnetic problem",
    "text": "Electromagnetic problem\nThe EM problem is considerably more difficult to implement than it is to state. Although one only has two extra fields, \\(E_x\\) and \\(E_y\\), the system is now coupled, which means that the original \\(NN\\) matrix becmes a dense system of size \\(3N3N\\). Furthermore, the system becomes considerably harder for the LAPACK library to solve the linear problem. Here, band integrated matrices become a must in order to prevent singularities showing up from the Green’s tensor, which is implemented using a \\(M\\)-dyadic generalization of the \\(\\) matrix described in Da Luz, et al. (1997),\n\\[\\mathbf{M}_{ij}=\\int_{\\mathcal{C}_j}\\mathrm{d}{s'}\\;\\mathbf{G}^B(\\mathbf{r}_i,\\mathbf{r}(s’)).\\]\nUsing a compact notation, one obtains the \\(T\\)-dyadic which solves the numerical scattering problem,\n\\[\\mathbf{T}\\equiv\\gamma\\left[\\mathbf{1}\\hat{x}_\\ell\\hat{x}_\\ell-\\gamma M^{\\ell m}\\hat{x}_\\ell\\hat{x}_m\\right]^{-1},\\]\nwhere \\(\\hat{x}_\\ell\\hat{x}_m\\) represents a dyad.\n\n\n\nAttempt to reproduce Mie scattering.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Application to optical problems"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/introduction.html#further-steps",
    "href": "posts/boundary-wall/docs/introduction.html#further-steps",
    "title": "Application to optical problems",
    "section": "Further steps",
    "text": "Further steps\nThe growth of the operator compared to the boundary resolution implies the need for either heriarchical matrices or preconditioning using wavelets.\n\nMore posts:",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Application to optical problems"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/lattice.html",
    "href": "posts/boundary-wall/docs/lattice.html",
    "title": "Lattices & Grids",
    "section": "",
    "text": "These methods implement grids similar to a Bravais lattice, as well as their repetition scheme.\n\n\n\n\n\nAll buildGrid functions construct a grid with \\(n\\\\_1\\times n\\\\_2\\) elements (depending on their basis vectors).\nbuildGrid\n@example grids buildGrid(HexagonalGrid(SVector(0.0, 0.0), 0.5), 8, 6) |&gt; scatter\nOne can use these as centers for other boundaries.\nusing LinearAlgebra\nusing StaticArrays: SVector\n\nimport BoundaryWall as BWM\n\nN    = 9                         # number of points per element\nR    = 1.0\nθ    = LinRange(0, 2pi, N+1)\nTH   = 180                  # incident angle\n\nSTEP = 2.0R + R/2 # diameter  + constant\nN_CIRCLES = (10,7)\nRANGES = [-(N_CIRCLES[1]-1)*STEP/2:STEP:(N_CIRCLES[1]-1)*STEP/2,-(N_CIRCLES[2]-1)*STEP/2:STEP:(N_CIRCLES[2]-1)*STEP/2]\nN_STEPS =length(RANGES)\nCENTERS = vec([(i, j) for i in RANGES[1], j in RANGES[2]])\n\n# delete some indices\nINDICES = sort([31,32,33,43,44,45,46,47,48,38,39, 40, 23, 24, 25, 26, 27, 28])\n\ndeleteat!(CENTERS, INDICES)\n\nCIRCLES = [BWM.createCircle(R, θ, SVector(cen)) for cen in CENTERS]\n# ...\nOne then can proceed to plot such circles. The details can be found in the documentation\n\n\n\nalt text",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Lattices & Grids"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/lattice.html#methods",
    "href": "posts/boundary-wall/docs/lattice.html#methods",
    "title": "Lattices & Grids",
    "section": "",
    "text": "All buildGrid functions construct a grid with \\(n\\\\_1\\times n\\\\_2\\) elements (depending on their basis vectors).\nbuildGrid\n@example grids buildGrid(HexagonalGrid(SVector(0.0, 0.0), 0.5), 8, 6) |&gt; scatter\nOne can use these as centers for other boundaries.\nusing LinearAlgebra\nusing StaticArrays: SVector\n\nimport BoundaryWall as BWM\n\nN    = 9                         # number of points per element\nR    = 1.0\nθ    = LinRange(0, 2pi, N+1)\nTH   = 180                  # incident angle\n\nSTEP = 2.0R + R/2 # diameter  + constant\nN_CIRCLES = (10,7)\nRANGES = [-(N_CIRCLES[1]-1)*STEP/2:STEP:(N_CIRCLES[1]-1)*STEP/2,-(N_CIRCLES[2]-1)*STEP/2:STEP:(N_CIRCLES[2]-1)*STEP/2]\nN_STEPS =length(RANGES)\nCENTERS = vec([(i, j) for i in RANGES[1], j in RANGES[2]])\n\n# delete some indices\nINDICES = sort([31,32,33,43,44,45,46,47,48,38,39, 40, 23, 24, 25, 26, 27, 28])\n\ndeleteat!(CENTERS, INDICES)\n\nCIRCLES = [BWM.createCircle(R, θ, SVector(cen)) for cen in CENTERS]\n# ...\nOne then can proceed to plot such circles. The details can be found in the documentation\n\n\n\nalt text",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Lattices & Grids"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/geometry.html",
    "href": "posts/boundary-wall/docs/geometry.html",
    "title": "Geometry",
    "section": "",
    "text": "The effective use of the Boundary Wall Method (BWM) requires equal-length segments. and the need to interpolate uneven curves. While one might have an equispaced (x-y) domain, the arc length (s) need not be homogeneous.\nThe general steps for using this toolbox with a custom array of points are the following: 1. Define ((x_i,y_i)) - (Re)discretize using\nFor closed curves, we implement the discretizeCurve function in order to interpolate the whole arc length into (N) equal segments. For open curves, one must use discretizeResonatorCurve (it can be used for closed curves as well, but be mindful of using (N) vs. (N+1) points). Interpolating with Interpolations.jl will work as well.\nOnce one has a relatively accurate arc length discretization, one must calculate midpoints using the calcMidpoints function. Note that the total number of midpoints must strictly match the dimensions of the () matrix.\nFinally, one might want to obtain the distance matrix representing ([]{ij}={i}-_{j}). The following example\nusing BoundaryWall, WGLMakie # hide\nθ     = LinRange(-pi, pi/2, 300)\nx,y   = cos.(θ),sin.(θ)\n\nx,y   = divideResonatorCurve(x,y, 300)\nxm,ym = calcMidpoints(x, y)\nds    = calcArcLength(x,y)\nrij   = calcDistances(xm, ym)\nlines(ds)\nA good way to check if one has done the discretization correctly is to check for the symmetry of the scattering () matrix, or to graph diff(ds) and check for homogeneous behaviour.\n\n\n\nThe package provides some useful functions such as createEllipse and createCircle in order to create analogues to rods.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Geometry"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/geometry.html#defining-curves",
    "href": "posts/boundary-wall/docs/geometry.html#defining-curves",
    "title": "Geometry",
    "section": "",
    "text": "The effective use of the Boundary Wall Method (BWM) requires equal-length segments. and the need to interpolate uneven curves. While one might have an equispaced (x-y) domain, the arc length (s) need not be homogeneous.\nThe general steps for using this toolbox with a custom array of points are the following: 1. Define ((x_i,y_i)) - (Re)discretize using\nFor closed curves, we implement the discretizeCurve function in order to interpolate the whole arc length into (N) equal segments. For open curves, one must use discretizeResonatorCurve (it can be used for closed curves as well, but be mindful of using (N) vs. (N+1) points). Interpolating with Interpolations.jl will work as well.\nOnce one has a relatively accurate arc length discretization, one must calculate midpoints using the calcMidpoints function. Note that the total number of midpoints must strictly match the dimensions of the () matrix.\nFinally, one might want to obtain the distance matrix representing ([]{ij}={i}-_{j}). The following example\nusing BoundaryWall, WGLMakie # hide\nθ     = LinRange(-pi, pi/2, 300)\nx,y   = cos.(θ),sin.(θ)\n\nx,y   = divideResonatorCurve(x,y, 300)\nxm,ym = calcMidpoints(x, y)\nds    = calcArcLength(x,y)\nrij   = calcDistances(xm, ym)\nlines(ds)\nA good way to check if one has done the discretization correctly is to check for the symmetry of the scattering () matrix, or to graph diff(ds) and check for homogeneous behaviour.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Geometry"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/geometry.html#builtin-methods",
    "href": "posts/boundary-wall/docs/geometry.html#builtin-methods",
    "title": "Geometry",
    "section": "",
    "text": "The package provides some useful functions such as createEllipse and createCircle in order to create analogues to rods.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Geometry"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/overview.html",
    "href": "posts/boundary-wall/docs/overview.html",
    "title": "BoundaryWall.jl, a quick overview",
    "section": "",
    "text": "Simple toolbox that implements an integral method for solving for an incident (TM) wave with well behaved scatterers.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "BoundaryWall.jl, a quick overview"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/overview.html#overview",
    "href": "posts/boundary-wall/docs/overview.html#overview",
    "title": "BoundaryWall.jl, a quick overview",
    "section": "Overview",
    "text": "Overview\nBoundaryWall.jl provides a collection of algorithms and tools for calculating the scattering of arbitrary boundaries, based upon the work of M. G. E. da Luz, A. S. Lupu-Sax, and E. J. Heller on Quantum Scattering, written in pure Julia.\nThe design of this project was motivated for calculating eigenstates and scattering wavefunctions in billiards (F.M. Zanetti et al., A. Ruiz-Biestro et al.).\nThis raises an important detail about possible applications. This is a Boundary Integral Method, which limits the applicable domains to 2D curves consisting of: simply connected curves, open curves, or a collection of the previous two. Boundaries with intersections and inner loops will generally not work. While the method does not require a parametrization of the boundary, it does require certain homogeneity in arc length. For more details about the implementation and theoretical foundations, see the Geometry section.\n\n\n\n\nalt text\n\n\nIf you have questions or would like to brainstorm ideas, don’t hesitate to contact me. I’d be happy to talk about the project and improve the toolbox in general.",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "BoundaryWall.jl, a quick overview"
    ]
  },
  {
    "objectID": "posts/boundary-wall/docs/tutorials/photonic.html",
    "href": "posts/boundary-wall/docs/tutorials/photonic.html",
    "title": "Photonic crystal",
    "section": "",
    "text": "Photonic crystal\nAs usual, import relevant libraries.\nusing LinearAlgebra\nusing StaticArrays: SVector\nusing SpecialFunctions\n# using GLMakie; GLMakie.activate!(inline=false, float=true)\nusing CairoMakie\nimport BoundaryWall as BWM\nNow we can define our constants for the problem.\n# CONSTANTS\nN    = 9                         # number of points per element\nHBAR = 1.0\nMASS = 0.5\nHBAR = 1.0\nSIGMA= (2*MASS/HBAR^2)*(1/4*im)\nNDOM = 100\nzero = 13.3237\nR    = 1.0\nθ    = LinRange(0, 2pi, N+1)\nTH   = 180\nKVEC = SVector(cosd(TH), sind(TH))\nPOTENTIAL_STRENGTH = -100.0\nBANDED = 3\n…and the geometry of such problem.\n\nSTEP = 2.0R + R/2 # diameter  + constant\nN_CIRCLES = (10,7)\nRANGES = [-(N_CIRCLES[1]-1)*STEP/2:STEP:(N_CIRCLES[1]-1)*STEP/2,-(N_CIRCLES[2]-1)*STEP/2:STEP:(N_CIRCLES[2]-1)*STEP/2]\nN_STEPS =length(RANGES)\nCENTERS = vec([(i, j) for i in RANGES[1], j in RANGES[2]])\n\nINDICES = sort([31,32,33,43,44,45,46,47,48,38,39, 40, 23, 24, 25, 26, 27, 28])\n\ndeleteat!(CENTERS, INDICES)\n\n# POTENTIAL_STRENGTH = repeat(STRENGTH, inner=N)\nCIRCLES = [BWM.createCircle(R, θ, SVector(cen)) for cen in CENTERS]\nx = vcat(getindex.(CIRCLES, 1)...)\ny = vcat(getindex.(CIRCLES, 2)...)\nxm= vcat(getindex.(CIRCLES, 3)...)\nym= vcat(getindex.(CIRCLES, 4)...)\nds= vcat(getindex.(CIRCLES, 5)...)\nrij = BWM.calcDistances(xm,ym)\nPlotting this results in the following diagram,\n\n\n\nalt text\n\n\nThe core of the library is the ability to have any superposition of plane waves impinge on the geometry. In this example, we focus a gaussian beam with certain waist parameters into the photonic cavity. One can observe that for different frequencies defined in ur FREQS vector, the system repsonds differently, allowing (or not) the wave to pass through, like a filter.\n# domain\nx0, xf = (-15.,15.)\ny0, yf = (-10.,10.)\nxdom = LinRange(x0, xf, NDOM)\nydom = LinRange(y0, yf, NDOM)\nCOORDS = [(_x,_y) for _x in xdom, _y in ydom]\nXDOM, YDOM = first.(COORDS)[:], last.(COORDS)[:]\n\n@inline function wave_function(_freq::Float64, _kvec::SVector{2, Float64}, _width::Float64)\n  return abs2.(reshape(\n    BWM.boundaryWallWave(_freq * _kvec, (k,r)-&gt;BWM.gaussianWave(k,r - SVector(-10.25, 0.0), _width; abstol=1e-3), x, y, xm, ym, XDOM, YDOM, SIGMA, ds, rij, length(ds), N, BANDED, POTENTIAL_STRENGTH),\n    NDOM, NDOM\n    )\n  )\nend\nFREQS = [1.35, 1.55, 1.65]\n\nwaves = [wave_function(f, KVEC, 4.0) for f in FREQS]\n\n\n\nalt text\n\n\nWe can analyze the flow of the field using the BWM.gradient(xdom, ydom, psi) function, which returns\n[ (^)]",
    "crumbs": [
      "Posts",
      "Boundary Wall",
      "Docs",
      "Tutorials",
      "Photonic crystal"
    ]
  },
  {
    "objectID": "posts/waves.html",
    "href": "posts/waves.html",
    "title": "Waves",
    "section": "",
    "text": "Wave simulations are essential in optics and electrodynamics. Here are some of the simulations I’ve done for wave propagation using finite-difference schemes.\n\n\nDiscrete wave equation\nIn general, using a FDTD scheme is just a fancy way of discretizing a differential operator. In this case, we want to discretize the following equation,\n\\[\\begin{equation}\\partial^2_{t}\\psi(\\mathbf{r},t)-\\alpha^2{\\Delta}\\psi(\\mathbf{r},t)=0\\quad (+\\phi),\\end{equation}\\]\nwith \\(\\Delta\\) being Laplace’s operator. One can also add a source term, \\(\\phi\\), but this does not cause any major differences when discretizing the homogeneous equation. Wikipedia’s page on the Discrete Laplace Operator gives a great insight into how the method works for \\(\\mathcal{O}(h^2)\\) error. Long story short, we deal with a generalization of the central finite difference method for higher dimensions. In 1D, one has the coefficients \\((1,-2,1)\\), which discretize \\(\\partial_x^2\\). In 2D, the same coefficients apply, but now in the perpendicular direction. In a cartesian grid, this translates to having a column vector of coefficients \\((1,2,1)^T\\). For 3D, the same methodology applies. Having the connection between the differential operator and its discrete version \\(\\Delta_{x,y,z}\\rightarrow \\mathbf{D}_{i,j,k}^2\\), one can infer the structure of the kernel to be used,\n\\[\\begin{equation}\\Delta\\equiv\\partial^2_x+\\partial^2_y+\\partial_z^2\\end{equation}\\]\n\\[\\begin{equation}\\mathbf{D}_{i,j,k}^2\\equiv\\mathbf{D}^2_i+\\mathbf{D}^2_j+\\mathbf{D}^2_k\\end{equation}\\]\n\\[\\begin{equation}\n\\mathbf{D}^2_{(i,j,k=-1)}=\n\\begin{pmatrix}\n0&0&0\\\\\n0&1&0\\\\\n0&0&0\\\\\n\\end{pmatrix},\n\\end{equation}\\] \\[\\begin{equation}\n\\mathbf{D}^2_{(i,j,k=0)}=\\begin{pmatrix}0&1&0\\\\1&-6&1\\\\0&1&0\\end{pmatrix},\n\\end{equation}\\] \\[\\begin{equation}\n\\quad\\mathbf{D}^2_{(i,j,k=1)}=\\begin{pmatrix}0&0&0\\\\0&1&0\\\\0&0&0\\end{pmatrix}\\end{equation}\\]\nIn fact, image processing software and tools use this types of convolution kernels for filters and other algorithms. For hicher precision, one replaces the centered difference with its respective weights (these are listed in this page). Although more precise, it has the disadvantage of requiring a bigger stencil and having wider boundaries.\nThe above formulation is an alternative to what is done in realistic codes, where one instead creates a super-matrix that corresponds to the kronecker product of the derivative operators, i.e.\n\\[\\begin{equation}\nD_{x,y}=D_x\\otimes I_{N_y} + I_{N_x} \\otimes D_y\n\\end{equation}\\]\n\n\n\n  \n    \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\nFor example, for the eigenmodes of an L-shaped cavity,\n\nnx = 130; ny = 120\n\nx1 = LinRange(-1, 1, nx)\nx2 = LinRange(-1, 1, ny)\n\ncond = [!((x &lt; 0) && (y &lt; 0)) for x in x1, y in x2]\n\ndx1 = x1[2]-x1[1]\ndx2 = x2[2]-x2[1]\n\nDx = diff2mat(nx, dx1, false)\nDy = diff2mat(ny, dx2, false)\n\nD = kron(speye(ny), Dx) + kron(Dy, speye(nx))\n\nDi = D .* vec(cond)\n\nvals, vecs = eigs(Di, which = :SR, 1e-10,maxiter=1500, nev = 10)\n\nfig = Figure(theme=theme_web()) \ngl = GridLayout(fig[1,1]) \nax = [Axis(gl[i,j]) for j in 1:3, i in 1:2] \nfor j in eachindex(ax) \n  psi = reshape(vecs[:,j], nx, ny) \n  psi[.!(cond)] .= NaN \n  heatmap!(ax[j], x1, x2, abs.(psi), colormap = :plasma) \n  ax[j].aspect = DataAspect() \n  hidedecorations!(ax[j]) \n  hidespines!(ax[j]) \nend\n\n\n\n\n  \n    \n    \n  \n  \n    \n    \n      \n    \n  \n\n\n\n\n\nAbsorbing Boundary Conditions\nWhen using Finite Difference Schemes alongside ABCs, one must remember to apply it to the entire boundary. For example, when using a FDM of order \\(O(h^6)\\), the region on the boundary has element-size 3. The absorbing boundary conditions (ABCs) implemented what Gerrit Mur derived in a 1981 IEEE Transactions article. Although Perfectly-Matched-Layer (PML) method is far more robust than traditional ABCs, it has been coded by various software developers (such as in COMSOL) far better than I could. As a rule of thumb, use a PML thickness similar to half the largest wavelength.\n\n\n3D example\nAt the top of the page I present a 3D solution of the discrete wave equation, using an approximation with error \\(\\mathcal{O}(h^6)\\), with absorbing boundary conditions.",
    "crumbs": [
      "Posts",
      "Waves"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Below are some of my recent projects and animations. Click on any of them to learn more and see the code.\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nGeometry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLattices & Grids\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoundaryWall.jl, a quick overview\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApplication to optical problems\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhotonic crystal\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBeam Splitter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLandau-Ginzburg\n\n\nSymmetries and mean-field theories\n\n\n\n\n\n\n\n\n4/9/25\n\n\n\n\n\n\n\n\n\n\n\n\nWaves\n\n\nFinite difference methods\n\n\n\n\n\n\n\n\n6/11/23\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Alberto Ruiz Biestro",
    "section": "",
    "text": "Email\n  \n  \n    \n     Github\n  \n\n  \n  \nCurrently a graduate Physics & Astronomy student @ Rice University. I completed my BSc. in Engineering Physics at Monterrey Institute of Technology, where I did my research in computational optics and quantum billiards. My fields of interest vary from quantum computing to photonics, computational physics, and more. Proficient in Julia, MATLAB, and Python. Know my way around Mathematica.\n\n\n\nRice University, TX\nPhD in Physics & Astronomy\n2024 – Present\nMonterrey Institute of Technology NL, Mexico\nBSC in Engineering Physics\n2020 – 2024",
    "crumbs": [
      "Alberto Ruiz (Bio)"
    ]
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Alberto Ruiz Biestro",
    "section": "",
    "text": "Rice University, TX\nPhD in Physics & Astronomy\n2024 – Present\nMonterrey Institute of Technology NL, Mexico\nBSC in Engineering Physics\n2020 – 2024",
    "crumbs": [
      "Alberto Ruiz (Bio)"
    ]
  }
]