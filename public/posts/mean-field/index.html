<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <script>
        
        const currentTheme = localStorage.getItem('theme');
        
        if (currentTheme === 'dark') {
            document.documentElement.classList.add('dark-mode');
        }
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mean field theory | Alberto Ruiz Biestro</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <link rel="stylesheet" href="/css/hankel.css">
    
    <link rel="icon" href="/images/icosahedron.gif" type="image/x-icon">
    

    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$']],
                processEscapes: true
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

    <div class="container-x">
        <nav class="nav-x">
            <div class="nav-links">
                
                    <a href="/">Alberto Ruiz-Biestro</a>
                
                    <a href="/">/home</a>
                
                    <a href="/posts/">/posts</a>
                
                    <a href="https://github.com/biestro/BoundaryWall.jl?tab=readme-ov-file#boundarywalljl">/code</a>
                
            </div>

            <button id="theme-toggle" aria-label="Toggle Dark Mode">Theme</button>
        </nav>

        <main>
            
<article>
    <header>
        <h1 class="post-title">Mean field theory</h1>
        <div class="post-meta">April 9, 2025 &middot; 909 words</div>
    </header>

    <div class="post-content">
        <h2 id="landau-ginzburg-theory">Landau-Ginzburg theory</h2>
<p>Essentiaylly, one expands the free energy functional $F[m]$ in $m$ and its
gradients while satisfying the proposed symmetries. The coarse-grained extension
to the Ising Hamiltonian is given by a <em>Landau-Ginzburg</em> Hamiltonian</p>
<p>$$
H[m] = \int d\vec{r}\left[ \frac{a}{2}m^2 + bm^4 + \frac{K}{2} (\nabla m)^2 +\dots\right]
$$</p>
<p>This has profound consequences in the statistical theory of fields (using
saddle-point approximations to recover Landau&rsquo;s theory),
but I won&rsquo;t discuss this here (see <a href="https://www.cambridge.org/core/books/statistical-physics-of-fields/06F49D11030FB3108683F413269DE945">Kardar&rsquo;s book</a>).
Here, $m(\vec{x})$ can be interpreted to be order-parameters, but in essence
are random fields, i.e. a field with a Boltzmann weight.</p>
<p>The above expression is not a kinetic expression. If we want to analyze the relaxation
of a system to the equilibrium configuration, we should introduce dynamics of the
field $m(\vec{x})$, which are given by a Langevin equation</p>
<p>$$
\dot{\vec{x}}=\vec{v}(\vec{x})+\vec{\eta}(t),
$$</p>
<p>where the second term, the stochastic velocity, has zero mean. It is direct to see
that for our Landau-Ginzburg Hamiltonian we have</p>
<p>\begin{align}
\partial_t m_i(\vec{x},t) &amp;=\mu F_i(\vec{x})+\eta_i(\vec{x},t)\\
&amp;=-\mu\frac{\delta F_i}{\delta m_i(\vec{x})}+\eta_i(\vec{x},t)\\
&amp;=-\mu(am_i+4b m_i|\vec{m}|^2-K\nabla^2m_i)+\eta_i(\vec{x},t)\\
\partial_t \vec{m}(\vec{x},t)&amp;=-\mu(a\vec{m}+4b \vec{m}|\vec{m}|^2-K\nabla^2\vec{m})+\eta_i(\vec{x},t)
\end{align}</p>
<p>This last equation is the <em>time-dependent</em> Landau-Ginzburg Hamiltonian. Since this
is a nonlinear equation, we resort to numerical methods to solve for the dynamics.</p>
<h2 id="solving-the-time-dependent-landau-ginzburg-equation">Solving the time-dependent Landau-Ginzburg equation</h2>
<p>The order parameter or field has no restrictions on its dimensions. Simulating a
bidimensional magnetization can be achieved by using complex numbers (say real for
$m_x$ and imaginary for $m_y$). Lets focus on a scalar field first and see how
it evolves in time, first in 2D and then in 3D.</p>
<h3 id="2d-treatment">2D treatment</h3>
<p>Consider a complex field $\phi$. We set the parameter $a$ to be negative for us to have <a href="https://en.wikipedia.org/wiki/Spontaneous_symmetry_breaking#A_pedagogical_example:_the_Mexican_hat_potential">Goldstone modes</a>. We further set $b=1.0 + 1.5i$ after some examples I saw after lurking online for the time-dependent LG equation.</p>
<p>To simulate the 2D case, we can use Julia&rsquo;s DifferentialEquations.jl package to solve for a complex field $\phi$. The spatial gradients were implemented as convolution operators using custom finite difference kernels, which were generated by the <code>finite_diff_coefficient</code> and <code>get_laplace_kernel</code> functions.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">function</span> finite_diff_coefficient(_ord<span style="color:#666">::</span><span style="color:#902000">Int64</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> _ord <span style="color:#666">==</span> <span style="color:#40a070">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> [<span style="color:#40a070">1</span>,<span style="color:#666">-</span><span style="color:#40a070">2</span>,<span style="color:#40a070">1</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">elseif</span> _ord <span style="color:#666">==</span> <span style="color:#40a070">4</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> [<span style="color:#666">-</span><span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">12</span>, <span style="color:#40a070">4</span><span style="color:#666">/</span><span style="color:#40a070">3</span>, <span style="color:#666">-</span><span style="color:#40a070">5</span><span style="color:#666">/</span><span style="color:#40a070">2</span>, <span style="color:#40a070">4</span><span style="color:#666">/</span><span style="color:#40a070">3</span>, <span style="color:#666">-</span><span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">12</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">elseif</span> _ord <span style="color:#666">==</span> <span style="color:#40a070">6</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> [<span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">90</span>, <span style="color:#666">-</span><span style="color:#40a070">3</span><span style="color:#666">/</span><span style="color:#40a070">20</span>, <span style="color:#40a070">3</span><span style="color:#666">/</span><span style="color:#40a070">2</span>, <span style="color:#666">-</span><span style="color:#40a070">49</span><span style="color:#666">/</span><span style="color:#40a070">18</span>,<span style="color:#40a070">3</span><span style="color:#666">/</span><span style="color:#40a070">2</span>,<span style="color:#666">-</span><span style="color:#40a070">3</span><span style="color:#666">/</span><span style="color:#40a070">20</span>,<span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">90</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">elseif</span> _ord <span style="color:#666">==</span> <span style="color:#40a070">8</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">return</span> [<span style="color:#666">-</span><span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">560</span>,<span style="color:#40a070">8</span><span style="color:#666">/</span><span style="color:#40a070">315</span>,<span style="color:#666">-</span><span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">5</span>,<span style="color:#40a070">8</span><span style="color:#666">/</span><span style="color:#40a070">5</span>,<span style="color:#666">-</span><span style="color:#40a070">205</span><span style="color:#666">/</span><span style="color:#40a070">72</span>,<span style="color:#40a070">8</span><span style="color:#666">/</span><span style="color:#40a070">5</span>,<span style="color:#666">-</span><span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">5</span>,<span style="color:#40a070">8</span><span style="color:#666">/</span><span style="color:#40a070">315</span>,<span style="color:#666">-</span><span style="color:#40a070">1</span><span style="color:#666">/</span><span style="color:#40a070">560</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">end</span>
</span></span></code></pre></div><p>The idea for this is to be able to implement the kernel in any number of dimensions, therefore these functions work for both 2D and 3D (and even 1D if you want to try it out).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">function</span> get_laplace_kernel(_dim<span style="color:#666">::</span><span style="color:#902000">Int64</span>,_ord<span style="color:#666">::</span><span style="color:#902000">Int64</span>)
</span></span><span style="display:flex;"><span>  base_ker <span style="color:#666">=</span> finite_diff_coefficient(_ord)
</span></span><span style="display:flex;"><span>  kernel <span style="color:#666">=</span> zeros(fill(length(base_ker),_dim)<span style="color:#666">...</span>)
</span></span><span style="display:flex;"><span>  mid_index <span style="color:#666">=</span> _ord÷2<span style="color:#666">+</span><span style="color:#40a070">1</span>
</span></span><span style="display:flex;"><span>  kernel[fill(mid_index,ndims(kernel)<span style="color:#666">-</span><span style="color:#40a070">1</span>)<span style="color:#666">...</span>,<span style="color:#666">:</span>] <span style="color:#666">.=</span> base_ker <span style="color:#60a0b0;font-style:italic"># middle of middles</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  perm_ind <span style="color:#666">=</span> collect(permutations(<span style="color:#40a070">1</span><span style="color:#666">:</span>_dim))<span style="color:#60a0b0;font-style:italic">#[1:_dim-1:end]</span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">if</span> _dim <span style="color:#666">==</span> <span style="color:#40a070">3</span>
</span></span><span style="display:flex;"><span>  filter!(_i <span style="color:#666">-&gt;</span> levicivita(_i) <span style="color:#666">&lt;</span> <span style="color:#40a070">0</span>, perm_ind)
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">end</span>
</span></span><span style="display:flex;"><span>  kernel <span style="color:#666">=</span> mapreduce(_i <span style="color:#666">-&gt;</span> permutedims(kernel,_i),<span style="color:#666">+</span>,perm_ind)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#60a0b0;font-style:italic">#two_dim_ker += permutedims(two_dim_ker)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">return</span> centered(kernel) <span style="color:#60a0b0;font-style:italic"># return centered version of kernel (0 = middle)</span>
</span></span><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">end</span>
</span></span></code></pre></div><p>Finally, the dynamics were defined in the <code>diff_eq</code> function, which computes the time derivative of the field $u$ based on the parameters $\mu$, $a$, $b$, $K$, and the Laplacian kernel. The periodic boundary conditions were handled using circular convolution from the <code>ImageFiltering</code> package in Julia (thankful I did not have to program the convolutions myself!). This approach may be most efficient for 2D arrays, and makes it simpler to implement and worry about the physics rather than the programming details (like the periodic boundary conditions).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">function</span> diff_eq(u , p, t)
</span></span><span style="display:flex;"><span>  <span style="color:#60a0b0;font-style:italic"># dp/dt = mu*F+eta</span>
</span></span><span style="display:flex;"><span>  μ,a,b,K,del_sq,dx <span style="color:#666">=</span> p
</span></span><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">return</span> <span style="color:#666">-</span>μ<span style="color:#666">*</span>(a <span style="color:#666">*</span> u <span style="color:#666">+</span> <span style="color:#40a070">4</span><span style="color:#666">*</span>b<span style="color:#666">*</span>abs2<span style="color:#666">.</span>(u) <span style="color:#666">.*</span> u <span style="color:#666">-</span> K <span style="color:#666">*</span> imfilter(u, del_sq, <span style="color:#4070a0">&#34;circular&#34;</span>) <span style="color:#666">/</span> dx<span style="color:#666">^</span><span style="color:#40a070">2</span>) <span style="color:#60a0b0;font-style:italic"># periodic boudnary conditions</span>
</span></span><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">end</span>
</span></span></code></pre></div><p>The following heatmap shows the results of an initial random spin configuration (like with the <a href="../../posts/ising">ising model</a>). I believe the sustained oscillations are due to the system exploring the possible configurations. For example, in a 1D Heisenberg model (XY model), one can think of the order parameter $\langle\vec{s}\rangle$ to be degenerate since (for the certain parameters) rotations around the $\hat{z}$ axis will not affect the free energy. Such states are called low-energy excitations of the system.</p>
<p>One can check that this absence of low-energy excitations can also happen for a complex-valued field ($b\in\mathbb{C}$), as long as $a&gt;0$.
As seen above, the order parameter is &ldquo;free&rdquo; to explore all the configurations around the black line. However, when we initialize the system in a purely real field (or with $a&gt;0$), there are no low-energy excitations present, and instead the system relaxes towards a single minima.</p>
<h3 id="3d-treatment">3D treatment</h3>
<p>I have already explained that the above functions work for ay dimension. However, the only change is that in 3D,
multiplication becomes a bit more expensive, and we&rsquo;re dealing with even more data-points. It is convenient to use
a simple <em>workhorse</em> for solving the dynamics, the Euler method with small time step. We also include a random (Gaussian)
velocity in each time-step as to account for random fluctuations.</p>
<p>Here, rather than starting with a random distribution, we start with a Gaussian field at the origin. As expected, low-energy excitations emerge.</p>
<h3 id="cahn-hilliard-equation">Cahn-Hilliard equation</h3>
<p>A friend interested in phase separation (and more experience in physics than I) suggested I read about the Cahn-Hilliard model after showing him the simluations above. Modifying the above code is trivial (just includes another convolution); below is a simulation of such separation using a balanced mixture (following the Cahn-Hilliard model), when constrained to a box (i.e. no periodic boundary conditions).</p>
<p>There is a great discussion on so called <em>dissipative</em> stochastic models (i.e. kinetic Ising models) in the wonderful book by <a href="https://www.cambridge.org/core/books/principles-of-condensed-matter-physics/70C3D677A9B5BEC4A77CBBD0A8A23E64">Chaikin and Lubensky</a>. It should be fun to implement the remaining models in the <em>A-J</em> list shown in page 467.</p>

    </div>
</article>

        </main>

        <footer>
            &copy; 2026 Alberto Ruiz-Biestro
        </footer>
    </div>

    <script>
        
        document.addEventListener("DOMContentLoaded", function() {
            const article = document.querySelector('article');
            if (article) {
                article.innerHTML = article.innerHTML.replace(
                    /\[\[(.*?)\]\]/g, 
                    function(match, text) {
                        const slug = text.trim().toLowerCase().replace(/\s+/g, '-');
                        return `<a href="/posts/${slug}" class="wikilink">${text}</a>`;
                    }
                );
            }
        });

        
        const toggleBtn = document.getElementById('theme-toggle');
        const htmlTag = document.documentElement;

        
        if (htmlTag.classList.contains('dark-mode')) {
            toggleBtn.innerText = "Light?";
        } else {
            toggleBtn.innerText = "Dark?";
        }

        toggleBtn.addEventListener('click', () => {
            htmlTag.classList.toggle('dark-mode');
            
            if (htmlTag.classList.contains('dark-mode')) {
                localStorage.setItem('theme', 'dark');
                toggleBtn.innerText = "Light?";
            } else {
                localStorage.setItem('theme', 'light');
                toggleBtn.innerText = "Dark?";
            }
        });
    </script>
</body>
</html>
